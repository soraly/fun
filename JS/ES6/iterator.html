<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Iterator</title>
</head>

<body>
    <h2>Iterotor</h2>
    <script>
        //1. 模拟一个遍历器生成函数，作用就是返回一个遍历器对象（指针对象）
        function makeIterator(array) {
            var index = 0;
            var length = array.length;
            return {
                next: () => {
                    return index < length ? { value: array[index++], done: false } : { value: undefined, done: true }
                }
            }
        }

        var it = makeIterator(['a', 'b']);  //创建一个指针对象
        it.next() //移动指针 --》 {value:'a', done:false}
        it.next() //{value:'b', done:false}
        it.next() //{value:undefined, done:true}

        //直接用for...of遍历 it 会报错，因为it没有Symbol.iterator属性，不是一个“可遍历的”结构

        //2. 模拟一个iterator
        var obj = {
            [Symbol.iterator]: function (array) {
                var index = 0;
                return {
                    next: () => {
                        return index < 10 ? { value: index++, done: false } : { value: index, done: true }
                    }
                }
            }
        }
        for (var val of obj) {
            //console.log(val,'val2')
        }

        //很多原生数据结构也具有Iterator 接口，比如：
        //Array, Map, Set, String, TypedArray, arguments, nodeList
        //数组的iterator
        var arr = [1, 222, 333, 'xiang', 'fenfen'];
        var itarr = arr[Symbol.iterator]();
        console.log(itarr.next().value);
        console.log(itarr.next().value);
        console.log(itarr.next().value);
        console.log(itarr.next().value);
        console.log(itarr.next().value);
        console.log(itarr.next().value);
        //可以写成for...of
        for (var item of itarr) {
            console.log(item)
        }

        //字符串的iterator
        var str = 'hello,xiang';
        var itstr = str[Symbol.iterator]();
        console.log(JSON.stringify(itstr.next), 'string_iterator');
        console.log(itstr.next())
        console.log(itstr.next())

        //用到Iterator接口的场合
        //对数组和 Set 结构进行解构赋值时，会默认调用Symbol.iterator方法
        //改写数组的遍历函数
        var array1 = ['xiang', 'fenfen', 1, 2];
        array1[Symbol.iterator] = function () {
            var index = 0;
            length = this.length;
            return {
                next: () => {
                    return index < length ? { value: this[index++] + "xixi", done: false } : { value: null, done: true }
                }
            }
        }
        array1.forEach(item => console.log(item, 'item')) //此处遍历不会调用Symbol.iterator
        var [man1, man2] = array1;
        console.log(man1, man2);

        //任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象
        function* myIterator() {
            console.log(this, 'thisssss')
            yield 'hello';
            yield 'xiang';
            return 'hello,xiang';
        }
        var obj2 = { id: 123 };
        obj2[Symbol.iterator] = myIterator;
        var tt = obj2[Symbol.iterator]();
        console.log(tt.next());
        for (var t of obj2) {
            console.log(t, 't') //注意：此处的return的 hello,xiang 不会被打印出来
        }


        //已经有个对象，然后要求用for...of 遍历出他的key和value
        var obj3 = { id: 123, name: 'xiamg', age: 22 }
        function* traversefn(obj) {
            var keys = Object.keys(obj);
            for (var i = 0; i < keys.length; i++) {
                yield keys[i] + ' : ' + obj[keys[i]]
            }
        }
        for (var key of traversefn(obj3)) {
            //console.log(key)
        }

        //改写
        var obj4 = { id: 22, name: 'xiamg', age: 33 }
        function* traversefn2() {
            var keys = Object.keys(this);
            console.log(keys, 'keys')
            for (var i = 0; i < keys.length; i++) {
                yield keys[i] + ' : ' + this[keys[i]]
            }
        }
        obj4[Symbol.iterator] = traversefn2;
        for (var key of obj4) {
            console.log(key)
        }

        //for...of外，... Array.from 解构赋值内部调用的都是遍历器接口，所以可以将将 Generator 函数返回的 Iterator 对象，作为参数。
        function* numbers() {
            yield 1
            yield 2
            return 3
            yield 4
        }
        // 扩展运算符
        [...numbers()] // [1, 2]
        // Array.from 方法
        Array.from(numbers()) // [1, 2]
        // 解构赋值
        let [x, y] = numbers();
        x // 1
        y // 2
        // for...of 循环
        for (let n of numbers()) {
            console.log(n)
        }
        // 1
        // 2

        
    </script>


</body>

</html>